\documentclass[11pt]{article}

\usepackage[letterpaper,margin=0.75in]{geometry}
\usepackage{booktabs}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{hyperref}

\setlength{\parindent}{1.4em}

\begin{document}

\lstset{
  language=Python,
  basicstyle=\small,          % print whole listing small
  keywordstyle=\bfseries,
  identifierstyle=,           % nothing happens
  commentstyle=,              % white comments
  stringstyle=\ttfamily,      % typewriter type for strings
  showstringspaces=false,     % no special string spaces
  numbers=left,
  numberstyle=\tiny,
  numbersep=5pt,
  frame=tb,
}

\title{Network Simulation}

\author{Cody Heffner}

\date{22 Jan. 2015}

\maketitle

\section{Preface}

This report details the experiment I ran and the results obtained as specified by the Network Simulation Lab in the BYU CS 460 class taught by Dr. Zappala. The project specifications can be found \href{http://cs460.byu.edu/winter-2015/labs/network-simulation}{here}.

The experiment requires heavy use of a network simulator to test different network scenarios. The network simulator I used is Dr. Zappala's \href{https://github.com/zappala/bene}{Bene}, written in Python. All my simulation examples shown will be tailored towards this simulator.

\section{Summary}

The goal of the experiment was to test various network scenarios by sending packets across networks of diverse bandwidth and distances, then observing the delays incurred by the transmission, propogation, and queueing of those packets in the network. The next section describes the experiment I ran with a simple two-node network and one bi-directional link set to various bandwidths and lengths. The following section reports the experiment I ran with a three-node network and two bi-directional links. The section after that describes the portion of the experiment that was used to validate queueing theory with regards to an M/D/1 queue on a network. The final section summarizes the experiment as a whole and discusses some things I did wrong during the experiment that gave me deeper insight into how the internet works.

\section{Two Nodes}

The network I created for this part of the experiment was a simple network consisting of two nodes and one bi-directional link. The following scenarios were tested:

\begin{enumerate}

\item One packet of length 1000 bytes sent from node n1 to node n2 at time 0. The network's bandwidth was 1Mbps with a propagation delay of 1 second.

\item One packet of length 1000 bytes sent from node n1 to node n2 at time 0. The network's bandwidth was 100bps with a propagation delay of 10 ms.

\item Three packets of length 1000 bytes sent from node n1 to node n2 at time 0, then one more packet sent at time 2. The network's bandwidth was 1Mbps with a propagation delay of 10 ms.

\end{enumerate}

The following two code blocks show how I set up the first scenario with one packet sent on a 1Mbps link and a propagation delay of 1. (Network setup for the other two scenarios are nearly exactly identical, so I have omitted the details from this report.) The first block of code is a Python snippet interacting with the Bene simulator. Line 3 builds a Network object as described in the file 2n1.txt, which is shown in the second code block below. Lines 6 and 7 of sim.py simply retrieve nodes for later use. Lines 8 and 9 add a forwarding entry in its forwarding tables for the other node. For example on line 8 the function \emph{add\textunderscore forwarding\textunderscore entry} takes the parameters \emph{address} and \emph{link}. \emph{Address} can be thought of as the receiving IP address n2 has designated to receive packets from n1; thus, the code needs to retrieve that address from n2's attributes. The parameter \emph{link} represents the physical line going out from n1 to n2. In this case it is the first and only link enumerated within n1's \emph{link} array. The forwarding entry is added to n1's forwarding tables.

\begin{lstlisting}
# sim.py
    # setup network
    net = Network('networks/2n1.txt')

    # setup routes
    n1 = net.get_node('n1')
    n2 = net.get_node('n2')
    n1.add_forwarding_entry(address=n2.get_address('n1'),link=n1.links[0])
    n2.add_forwarding_entry(address=n1.get_address('n2'),link=n2.links[0])

    # setup app
    d = DelayHandler()
    net.nodes['n2'].add_protocol(protocol="delay",handler=d)
\end{lstlisting}

The file 2n1.txt is relatively self-explanatory, but I'll go over it quickly. The first three lines are ignored. Lines 4 and 5 establish nodes and links between nodes. The first word represents a node to be created, and all following words on that same line represent a connection between the first word and each following word. Lines 8 and 9 configure links. The first two words target the start and end node of a link, and the last two words set that link to have a 1Mbps bandwidth and 1000ms (1 second) propagation delay.

\begin{lstlisting}
# 2n1.txt
    # n1 -- n2
    #
    n1 n2
    n2 n1

    # link configuration
    n1 n2 1Mbps 1000ms
    n2 n1 1Mbps 1000ms
\end{lstlisting}

The simulator simulates three types of delays that packets experience as they travel: transmission, propagation, and queueing. 

Transmission delay is calculated as the result of the size of the packet in bits divided by the bandwidth of the link it is being transmitted onto. In scenario 1, transmission delay is the result of (8,000 bits / 1,000,000 bps) = 0.008s.

Propagation delay is simply a factor of the distance and speed the packet has to travel, but in this experiment, the propagation delays are given. In scenario 1, propagation delay = 1s

Queueing delay is how long a packet has to wait after it is fully received by a node. The cause of queueing delay is solely a factor of how many packets are in line at a node when a packet needs to be sent. In scenario 1, only one packet ever exists, so there will be no queueing delay.

The total delay is the sum of all three of those delays.

The simulator can be shown as being accurate by comparing theoretical results with simulator results. The following tables compare the delay the packets experience in each situation as calculated by hand and the delay the simulator reported the packets experienced. In any scenarios with multiple packets, I will show the queueing delay as experienced by the packet with the largest queueing delay.

\vspace{0.5cm}
\begin{tabular}{lcc}
  \toprule
  Delay Type & Calculated & Simulated\\
  \midrule
  Transmission & 0.008s & 0.008s\\
  Propagation & 1s & 1s\\
  Queue & 0s & 0s\\
  Total & 1.008s & 1.008s\\
  \bottomrule
  Scenario 1
\end{tabular}
\vspace{0.5cm}

\vspace{0.5cm}
\begin{tabular}{lcc}
  \toprule
  Delay Type & Calculated & Simulated\\
  \midrule
  Transmission & 80s & 80s\\
  Propagation & 0.01s & 0.01s\\
  Queue & 0s & 0s\\
  Total & 80.01s & 80.01s\\
  \bottomrule
  Scenario 2
\end{tabular}
\vspace{0.5cm}

\vspace{0.5cm}
\begin{tabular}{lcc}
  \toprule
  Delay Type & Calculated & Simulated\\
  \midrule
  Transmission & 0.008s & 0.008s\\
  Propagation & 0.01s & 0.01s\\
  Queue & 0.016s & 0.016\\
  Total & 0.034s & 0.034s\\
  \bottomrule
  Scenario 3
\end{tabular}
\vspace{0.5cm}

In scenario 3, node n1 sends three packets back to back. N1 needs to place the third packet in a queue behind the other two while it transmits the first two. Therefore, the queueing delay for the third packet will be the largest and equal to two times the transmission delay for any packet.

As the three tables above show, the simulator is precise and accurate, finding each of the simulated delay values are equal to the calculated delay values. 

\section{Three Nodes}



\section{Queueing Theory}

\section{Conclusion}

\end{document}
